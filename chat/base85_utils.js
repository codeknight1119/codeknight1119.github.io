/**
 * Base85/Ascii85 Utility Functions for Encoding and Decoding Binary Data (like Images).
 * * Base85 converts 4 bytes (32 bits) of binary data into 5 characters, resulting in 
 * 25% overhead (5/4), which is more efficient than Base64's 33% overhead.
 */

const Base85Core = {
    // Standard Ascii85 character set (from '!' to 'u')
    BASIS: '!\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu',
    // Powers of 85: 85^4, 85^3, 85^2, 85^1, 85^0
    POW85: [52200625, 614125, 7225, 85, 1],

    /**
     * Encodes a Uint8Array (raw binary data) into a Base85 string.
     * This is the core engine for Base85 encoding.
     * @param {Uint8Array} data - The binary data to encode.
     * @returns {string} The Base85 encoded string.
     */
    encode(data) {
        let encoded = [];
        const basis = this.BASIS;
        const pow85 = this.POW85;
        const dataLength = data.length;
        
        for (let i = 0; i < dataLength; i += 4) {
            let currentBytes = Math.min(4, dataLength - i);
            let value = 0;

            // 1. Construct 32-bit value (Big Endian)
            for (let j = 0; j < currentBytes; j++) {
                // Shift bytes into position from left to right (MSB first)
                value += data[i + j] * Math.pow(256, 3 - j);
            }
            
            // 2. Padding (Zero-pad the 32-bit value if input block is < 4 bytes)
            value *= Math.pow(256, 4 - currentBytes);

            // Optional: 'z' zero-block optimization (only for full 4-byte blocks)
            if (value === 0 && currentBytes === 4) {
                encoded.push('z');
                continue;
            }

            let chars = [];
            let tempVal = value;
            
            // 3. Convert the 32-bit value into 5 base-85 digits
            for (let j = 0; j < 5; j++) {
                let digit = Math.floor(tempVal / pow85[j]);
                tempVal -= digit * pow85[j];
                chars.push(basis[digit]);
            }
            
            // 4. Truncation: If padded, drop the trailing characters that were generated by the padding
            if (currentBytes < 4) {
                // The number of output characters is (bytes + 1)
                chars.splice(currentBytes + 1);
            }
            
            encoded.push(...chars);
        }

        return encoded.join(''); 
    },

    /**
     * Decodes a Base85 string back into a Uint8Array (raw binary data).
     * This is the core engine for Base85 decoding.
     * @param {string} b85String - The Base85 string to decode.
     * @returns {Uint8Array} The decoded binary data.
     */
    decode(b85String) {
        let decoded = [];
        let buffer = []; // Stores Base85 digits (0-84)
        const basis = this.BASIS;
        const pow85 = this.POW85;
        const basisMap = {};
        for (let i = 0; i < basis.length; i++) basisMap[basis[i]] = i;

        // Strip non-Base85 characters and whitespace
        let data = b85String.replace(/\s/g, ''); 

        for (let i = 0; i < data.length; i++) {
            const char = data[i];

            if (char === 'z') {
                // Special case: 'z' expands to four zero bytes
                decoded.push(0, 0, 0, 0);
                continue;
            }
            
            const charIndex = basisMap[char];
            if (charIndex === undefined) continue; // Skip invalid characters
            
            buffer.push(charIndex);

            if (buffer.length === 5) {
                // Decode 5 characters (digits) into 4 bytes
                let value = 0;
                for (let j = 0; j < 5; j++) {
                    value += buffer[j] * pow85[j];
                }
                
                // Extract 4 bytes from the 32-bit value (Big Endian)
                decoded.push((value >> 24) & 0xFF);
                decoded.push((value >> 16) & 0xFF);
                decoded.push((value >> 8) & 0xFF);
                decoded.push(value & 0xFF);
                
                buffer = [];
            }
        }

        // Handle the remainder (1, 2, 3, or 4 characters left)
        const remainderLength = buffer.length;
        if (remainderLength > 1) {
            let value = 0;
            // Reconstruct the value from the remaining digits
            for (let j = 0; j < remainderLength; j++) {
                value += buffer[j] * pow85[j];
            }
            
            // The number of bytes encoded is remainderLength - 1
            let bytesOutput = remainderLength - 1;
            let correction = pow85[bytesOutput]; 

            // Apply correction factor: (correction - 1) is needed to account for truncation effects
            // This corrects for the implied zero padding during decoding.
            value += correction - 1;

            // Extract the valid bytes
            for (let j = 0; j < bytesOutput; j++) {
                decoded.push((value >> (24 - j * 8)) & 0xFF);
            }
        }
        
        return new Uint8Array(decoded);
    }
};


/**
 * Converts an ArrayBuffer to a Base64 string. Used only for generating the final Data URL.
 * @param {ArrayBuffer} buffer 
 * @returns {string} The Base64 encoded string.
 */
function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}


// ----------------------------------------------------------------------
// USER-FACING FUNCTIONS
// ----------------------------------------------------------------------


/**
 * Main utility to take a File object and return a Promise resolving to the Base85 string.
 * @param {File} imageFile - The image File object from an <input type="file">.
 * @returns {Promise<{base85String: string, mimeType: string}>} A promise that resolves with the Base85 string and MIME type.
 */
function encodeImageToBase85(imageFile) {
    return new Promise((resolve, reject) => {
        if (!imageFile) {
            return reject(new Error("No file provided for encoding."));
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = new Uint8Array(e.target.result);
                const base85String = Base85Core.encode(data);
                
                resolve({ 
                    base85String: base85String, 
                    mimeType: imageFile.type 
                });
            } catch (error) {
                reject(new Error(`Base85 encoding failed: ${error.message}`));
            }
        };

        reader.onerror = () => {
            reject(new Error("Failed to read the file into an ArrayBuffer."));
        };

        reader.readAsArrayBuffer(imageFile);
    });
}

/**
 * Main utility to take a Base85 string and return a Data URL (image source).
 * @param {string} base85String - The Base85 encoded string.
 * @param {string} mimeType - The original MIME type of the image (e.g., 'image/png').
 * @returns {string} The image Data URL ready to be set as an <img> element's src.
 */
function decodeBase85ToImageURL(base85String, mimeType) {
    if (!base85String || !mimeType) {
        throw new Error("Base85 string and MIME type are required for decoding.");
    }
    
    // 1. Decode Base85 string back to binary data (Uint8Array)
    const decodedUint8Array = Base85Core.decode(base85String);

    // 2. Convert the resulting binary data (ArrayBuffer) to a Base64 string
    const b64String = arrayBufferToBase64(decodedUint8Array.buffer);

    // 3. Construct the Data URL
    return `data:${mimeType};base64,${b64String}`;
}

// Example usage (optional, for demonstration)
/*
async function runExample(fileInputId) {
    const fileInput = document.getElementById(fileInputId);
    if (!fileInput.files.length) {
        console.log("Please select a file first.");
        return;
    }

    try {
        const { base85String, mimeType } = await encodeImageToBase85(fileInput.files[0]);
        console.log("Encoded Base85:", base85String);
        console.log("MIME Type:", mimeType);

        // Decode it back
        const dataUrl = decodeBase85ToImageURL(base85String, mimeType);
        // You can now set this dataUrl to an <img> element
        console.log("Decoded Data URL generated.");

    } catch (error) {
        console.error("Operation failed:", error);
    }
}
*/